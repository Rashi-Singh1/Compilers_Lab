%{
    #include <bits/stdc++.h>
    #include <stdio.h>
    #include <iostream>
    #include <stdlib.h>
    using namespace std;
    int yylex(); 
    void yyerror(const char *s);

    #define YYDEBUG 1
    #define MAX_ATTR_LIST 1024
    
    typedef
    struct custom_list{
        char * arr[MAX_ATTR_LIST];
        int last;
    } custom_list;
    
    void list_insert_string( custom_list* lst , char * str){
        // NULL check
        if(lst == NULL){
            cout << "inserting to NULL" << endl;
            return;
        }
        
        lst->arr[lst->last] = str;
        (lst->last)++;
        return; 
    }

    void copy_list( custom_list *list1 ,  custom_list list2){
        for(int i = 0; i < list2.last; ++i){
            list_insert_string(list1, (list2.arr)[i]);
        }
        return;
    }

    void list_show( custom_list* lst){
        if(lst == NULL){
            cout << "inserting to NULL" << endl;
            return;
        }
        
        cout << "custom_list entries-->";
        for(int i = 0; i < lst->last; ++i){
            cout << (lst->arr)[i] << " ";
        }
        cout << '\n';
        return;
    }
    bool cartesian_product(char *table_1 , char * table_2);
    bool project(custom_list * c , char * tbl);
%}

%union {
        char* str;
        void* attr_set;
        //  = (void *)malloc(sizeof(our_list));
       }
%start QUERY_LIST
%token MORE
%token RP
%token LP
%token EQUAL
%token COMMA
%token LESS
%token LESSEQUAL
%token MOREEQUAL
%token NOTEQUAL
%token WHITESPACE
%token NUM
%token QUOTE
%token SEMI
%token DOT
%token AND
%token OR
%token NOT
%token SELECT
%token PROJECT
%token CARTESIAN_PRODUCT
%token EQUI_JOIN
%token <str> ID 
%type <str> TABLE
%type <attr_set> ATTR_LIST


/* actual grammar implementation in C*/
%%
QUERY_LIST : QUERY SEMI | QUERY SEMI QUERY_LIST
;


QUERY : SELECT LESS SELECT_COND MORE LP TABLE RP {
        }

       | PROJECT LESS ATTR_LIST MORE LP TABLE RP {
           list_show((custom_list *)$3);

           if(project((custom_list *)$3 , $6)){
               cout << "succesful projection" << endl;
           }else{
               yyerror("unsuccesful projection");
           }

           free($6);
           free($3);
        }

       | LP TABLE RP CARTESIAN_PRODUCT LP TABLE RP {
           if(cartesian_product($2 , $6)){
               cout <<"performed successful cartesian product of " << $2 << " and " << $6 << '\n';
           } else{
               yyerror("unsuccesful cartesian product\n");
           }
           free($2);
           free($6);
        }
       
       | LP TABLE RP EQUI_JOIN LESS JOIN_COND MORE LP TABLE RP
;


TABLE : ID {
    cout << "table before table=id\t" << $$ << '\n';
    $$ = $1;
    cout << "table after assign\t" << $$ << '\n';
    }
;


ATTR_LIST : ID {
                custom_list * l_ptr = (custom_list *)malloc(sizeof(custom_list));
                list_insert_string(l_ptr, $1);
                $$ = (void *)(l_ptr);
            }
        | ID COMMA ATTR_LIST{
            list_insert_string((custom_list *) $3, $1);
            $$ = $3;
          }
;


SELECT_COND : OR_NOT_COND {
              }

            | OR_NOT_COND AND SELECT_COND {
              }
;


OR_NOT_COND : NOT_COND {
                printf("OR_NOT_COND -> NOT_COND\n");
              }

            | NOT_COND OR OR_NOT_COND {
                printf("OR_NOT_COND -> NOT_COND OR OR_NOT_COND\n");
              }
;


NOT_COND : NOT COND 
           | COND
;


COND : CONST_OR_ID OP CONST_OR_ID 
;


OP : EQUAL | LESS | MORE | LESSEQUAL | MOREEQUAL | NOTEQUAL 
;


CONST_OR_ID : ID | QUOTE ID QUOTE | NUM
;


JOIN_COND : EQUI_COND | EQUI_COND AND JOIN_COND
;


EQUI_COND : TABLE DOT ID EQUAL TABLE DOT ID
;


%%

int main(void){
    //yydebug = 1;
    return yyparse();
}
void yyerror(const char *s){
    cerr << s;
}
bool cartesian_product(char *table_1 , char * table_2){
    return true;
}

bool project(custom_list * c , char * tbl){
    return true;
}